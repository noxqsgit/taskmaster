#!/bin/bash

# --                                                            ; {{{1
#
# File        : taskmaster
# Maintainer  : Felix C. Stegerman <flx@obfusk.net>
# Date        : 2013-07-19
#
# Copyright   : Copyright (C) 2013  Felix C. Stegerman
# Licence     : GPLv2
#
# --                                                            ; }}}1

set -e

if [ "$1" == --help ]; then
  echo 'Usage: taskmaster [ <task>=<n> ... ]' >&2; exit 0
fi

# use fd 3 for logging output b/c stderr > stdout otherwise
# WTF: no output if redirected to file w/o >&3
exec 3>/dev/stdout >&3

# --

if [ -t 1 ]; then use_colour=yes; else use_colour=no; fi

 c_black='0;30'     c_blue='0;34'   c_green='0;32'    c_cyan='0;36'
   c_red='0;31'   c_purple='0;35'   c_brown='0;33'  c_l_gray='0;37'
c_d_gray='1;30'   c_l_blue='1;34' c_l_green='1;32'  c_l_cyan='1;36'
 c_l_red='1;31' c_l_purple='1;35'  c_yellow='1;33'   c_white='1;37'

colours=(
    $c_cyan   $c_brown   $c_green   $c_purple   $c_red   $c_blue
  $c_l_cyan $c_yellow  $c_l_green $c_l_purple $c_l_red $c_l_blue
) ; n_colours="${#colours[@]}"

word='[A-Za-z0-9]+' num='[0-9]+' esc=$'\e'

# Usage: colour <msg> { <i> | w }
function colour ()
{                                                               # {{{1
  local msg="$1" i="$2" j c
  if [ "$use_colour" == yes ]; then
    if [ "$i" == w ]; then
      c="$c_white"
    else
      j="$(( i % n_colours ))"; c="${colours[j]}"
    fi
    printf '%s\n' "${esc}[${c}m${msg}${esc}[0m"
  else
    printf '%s\n' "$msg"
  fi
}                                                               # }}}1

# Usage: verbose
function verbose () { [ "$VERBOSE" == yes ]; }

# --

tm_rc="${TASKMASTERRC:-.taskmaster}"
tm_tf="${TASKFILE:-Taskfile}"
tm_sh="${TASKMASTER_SHELL:-bash}"

tm_cwd= tm_logdir= tm_env=
tm_restart_strategy=one_for_one tm_maxR=10 tm_maxT=60
tm_worker=temporary

tm_pid="$$" tm_restart=() tm_restarts=0

# --

# Usage: dt
function dt () { date +'%F %T'; }

# Usage: secs
function secs () { date +'%s'; }

# Usage: die
function die () { echo "$@" >&2; exit 1; }

# Usage: ohai { <i> | w } <message(s)>
function ohai ()
{                                                               # {{{1
  local i="$1" o=; shift
  o+="$( colour "taskmaster $(dt)" w )"
  for m in "$@"; do o+=" -- $( colour "$m" "$i" )"; done
  echo "[ $o ]"
}                                                               # }}}1

# Usage: log <task> { OUT | ERR } { <i> | w }
# Reads from STDIN, then writes to STDOUT w/ extra info.
function log ()
{                                                               # {{{1
  local task="$1" what="$2" i="$3" REPLY
  while read -r; do
    printf '%s %s\n' "$( colour "$(dt) $what $task |" "$i" )" "$REPLY"
  done
}                                                               # }}}1

# --

# Usage: ensure_word <value>
function ensure_word ()
{ [[ "$1" =~ ^$word$ ]] || die "not a word: $1"; }

# Usage: ensure_num <value>
function ensure_num ()
{ [[ "$1" =~ ^$num$ ]] || die "not a number: $1"; }

# Usage: ensure_restart_strategy <value>
function ensure_restart_strategy ()
{ [[ "$1" =~ ^(one_for_all|one_for_one)$ ]] \
    || die "not a restart strategy: $1"; }

# Usage: ensure_worker <value>
function ensure_worker ()
{ [[ "$1" =~ ^(permanent|transient|temporary)$ ]] \
    || die "not a worker: $1"; }

# --

# Usage: cwd [<task(s)>] <dir>
# Sets $tm_cwd or $tm_cwd__{$task*}.
function cwd ()
{                                                               # {{{1
  ohai w "cwd $*"
  if [ "$#" -eq 1 ]; then
    tm_cwd="$1"
    verbose && ohai w "cwd=$tm_cwd"
  else
    local x d="${@:$#:1}"
    for x in "${@:1:$(($#-1))}"; do
      ensure_word "$x"; eval "tm_cwd__$x=\$d"
      verbose && ohai w "cwd[$x]=$d"
    done
  fi
}                                                               # }}}1

# Usage: logdir [<task(s)>] <dir>
# Sets $tm_logdir or $tm_logdir__{$task*}.
function logdir ()
{                                                               # {{{1
  ohai w "logdir $*"
  if [ "$#" -eq 1 ]; then
    tm_logdir="$1"
    verbose && ohai w "logdir=$tm_logdir"
  else
    local x d="${@:$#:1}"
    for x in "${@:1:$(($#-1))}"; do
      ensure_word "$x"; eval "tm_logdir__$x=\$d"
      verbose && ohai w "logdir[$x]=$d"
    done
  fi
}                                                               # }}}1

# Usage: environment [<task(s)>] VAR1=VAL1 ...
# Sets $tm_env or $tm_env__{$task*}.
function environment ()
{                                                               # {{{1
  local ts=() env i x
  ohai w "environment $*"
  for (( i = 0; i < $#; ++i )); do
    local x="${@:$i:1}"
    if [[ "$x" =~ ^$word$ ]]; then
      ts+=( "$x" )
    else
      break
    fi
  done
  env=( "${@:$i:$(($#-i))}" )
  for x in "${env[@]}"; do
    [[ "$x" =~ ^($word)= ]] || die "not a <word>=...: $x"
  done

  if [ "${#ts[@]}" -eq 0 ]; then
    tm_env=( "${env[@]}" )
    verbose && ohai w "env=${tm_env[*]}"
  else
    for x in "${ts[@]}"; do
      eval "tm_env__$x=( \"\${env[@]}\" )"
      verbose && ohai w "env[$x]=${env[*]}"
    done
  fi
}                                                               # }}}1

# Usage: concurrency <task1>=<n1> <task2>=<n2> ...
# Sets $tm_concurrency__{$task*}; should be called in $TASKMASTERRC.
function concurrency ()
{                                                               # {{{1
  local x t n
  ohai w "concurrency $*"
  for x in "$@"; do
    [[ "$x" =~ ^($word)=($num)$ ]] || die "not a <word>=<num>: $x"
    t="${BASH_REMATCH[1]}" n="${BASH_REMATCH[2]}"
    eval "tm_concurrency__$t=$n"
    verbose && ohai w "concurrency[$t]=$n"
  done
}                                                               # }}}1

# --

# Usage: restart_strategy { one_for_all | one_for_one }
# Sets $tm_restart_strategy.
function restart_strategy ()
{ ohai w "restart_strategy $1"
  ensure_restart_strategy "$1"; tm_restart_strategy="$1"; }

# Usage: max_restart <maxR> <maxT>
# Sets $tm_maxR, $tm_maxT.
function max_restart ()
{ ohai w "max_restart $*"
  ensure_num "$1"; ensure_num "$2"; tm_maxR="$1" tm_maxT="$2"; }

# Usage: worker [<task(s)>] { permanent | transient | temporary }
# Sets $tm_worker or $tm_worker__${task*}.
function worker ()
{                                                               # {{{1
  ohai w "worker $*"
  if [ "$#" -eq 1 ]; then
    ensure_worker "$1"; tm_worker="$1"
    verbose && ohai w "worker=$tm_worker"
  else
    local x d="${@:$#:1}"
    ensure_worker "$d"
    for x in "${@:1:$(($#-1))}"; do
      ensure_word "$x"; eval "tm_worker__$x=\$d"
      verbose && ohai w "worker[$x]=$d"
    done
  fi
}                                                               # }}}1

# --

# Usage: ohai_worker_exited
function ohai_worker_exited ()
{ ohai "$worker_i" "$worker_t exited" "exit=$worker_ret"; }

# Usage: spawn
# Sets $worker_{pid,ret}
function spawn ()
{                                                               # {{{1
  "$tm_sh" -c "$worker_cmd" & worker_pid=$!
  ohai "$worker_i" "starting $worker_t" "pid=$worker_pid"
  set +e; wait "$worker_pid"; worker_ret="$?"; set -e
}                                                               # }}}1

# Usage: spawn_permanent <i> <t> <cmd>
function spawn_permanent ()
{                                                               # {{{1
  while :; do
    spawn "$i" "$t" "$cmd"; ohai_worker_exited
    kill -SIGUSR1 "$tm_pid"
    sleep .5
  done
}                                                               # }}}1

# Usage: spawn_transient <i> <t> <cmd>
function spawn_transient ()
{                                                               # {{{1
  while :; do
    spawn "$i" "$t" "$cmd"; ohai_worker_exited
    [ "$worker_ret" -eq 0 ] && break
    kill -SIGUSR1 "$tm_pid"
    sleep .5
  done
}                                                               # }}}1

# Usage: spawn_temporary <i> <t> <cmd>
function spawn_temporary ()
{ spawn "$i" "$t" "$cmd"; ohai_worker_exited; }

# Usage: handle_EXIT_worker
function handle_EXIT_worker ()
{                                                               # {{{1
  local p
  for p in $( children "$BASHPID" ); do
    if [ "$p" == "$worker_pid" ]; then
      ohai "$worker_i" "kill $worker_t" "signal=$worker_sig pid=$p}"
      kill_w_children "$worker_sig" "$p"
    fi
  done
}                                                               # }}}1

# Usage: spawn_worker <i> <j> <k> <t> <l> <d> <w> <cmd> <sig>
# Sets $worker_i,t,cmd,sig,pid,ret,env}.
function spawn_worker ()
{                                                               # {{{1
  local i="$1" j="$2" k="$3" t="$4" l="$5" d="$6" w="$7" cmd="$8"
  local sig="$9"
  (
    worker_i="$i" worker_t="$t" worker_cmd="$cmd" worker_sig="$sig"
    worker_pid= worker_ret=
    eval "worker_env=( \"\${tm_env__${tasks[i]}[@]}\" )"        # TODO
    trap handle_EXIT_worker EXIT
    [ -n "$d" ] && chdir "$d"
    [ "${#tm_env[@]}"     -gt 0 ] && export "${tm_env[@]}"      # TODO
    [ "${#worker_env[@]}" -gt 0 ] && export "${worker_env[@]}"  # TODO
    if [ -n "$l" ]; then
      spawn_"$w" >> "$l/$t-stdout.log" \
                2>> "$l/$t-stderr.log"
    else
      spawn_"$w" > >( log "$t" OUT "$i" >&3 ) \
                2> >( log "$t" ERR "$i" >&3 )
    fi
  ) &
}                                                               # }}}1

# --

# Usage: alive <pid>
function alive () { test -n "$( ps -p "$1" -o pid= )"; }

# Usage: children <pid>
function children ()
{                                                               # {{{1
  local pid="$1" p pp
  while read -r p pp; do [ "$pp" == "$pid" ] && echo "$p"; done < \
    <( ps -e -o pid= -o ppid= )
}                                                               # }}}1

# Usage: kill_v -<sig> <pid>
function kill_v ()
{ verbose && ohai w "kill $*"; kill "$@"; }

# Usage: kill_children <pid>
function kill_children ()
{ local pid="$1" p
  for p in $( children "$pid" ); do kill_v -SIGTERM "$p"; done; }

# Usage: kill_w_children -<sig> <pid>
# Kills pid, sleeps 1 sec, kills remaining direct children.
function kill_w_children ()                                     # {{{1
{
  local sig="$1" pid="$2" p pp; local ps=( $( children "$pid" ) )
  kill_v "$sig" "$pid" ; sleep 1
  for p in "${ps[@]}"; do alive "$p" && kill_v "$sig" "$p"; done
  true
}                                                               # }}}1

# --

# Usage: handle_child_restart
# Handle child restarted (SIGUSR1).
function handle_child_restart ()
{                                                               # {{{1
  local now then
  ohai w 'a child has restarted'
  now="$( secs )"
  tm_restart["$(( tm_restarts % tm_maxR ))"]="$now"
  (( ++tm_restarts ))
  then="${tm_restart[$(( tm_restarts % tm_maxR ))]}"
  if [ -n "$then" ] && [ "$(( now - then ))" -lt "$tm_maxT" ]; then
    ohai w 'maximum restarts reached' 'exiting'
    kill_children "$tm_pid"
    exit 1
  elif [ "$tm_restart_strategy" == one_for_all ]; then
    ohai w 'restarting everyting (one_for_all)'
    kill_children "$tm_pid"
    exec "$0" "$@"
  fi
}                                                               # }}}1

# Usage: handle_INT
function handle_INT () { ohai w 'SIGINT received'; }

# Usage: handle_TERM
function handle_TERM () {ohai w 'SIGTERM received'; }

# Usage: handle_EXIT
function handle_EXIT ()
{ ohai w 'exiting'; kill_children "$tm_pid"; }

# --

# Usage: parse_Taskfile
# Parse $tm_tf; read w/o -r allows for continuation lines; appends to
# $tasks, $cmds, $sigs; sets $n_tasks.
function parse_Taskfile ()
{                                                               # {{{1
  local task cmd t s c
  while read task cmd; do
    [[ "$task" =~ ^($word):$ ]] || die "not a '<task>:': $task"
    t="${BASH_REMATCH[1]}"
    if [[ "$cmd" =~ ^(SIG[A-Z0-9]+\ *)(.*)$ ]]; then
      s="${BASH_REMATCH[1]}" c="${BASH_REMATCH[2]}"
    else
      s=SIGTERM c="$cmd"
    fi
    tasks+=( "$t" ); cmds+=( "$c" ); sigs+=( "$s" )
  done < "$tm_tf"
  n_tasks="${#cmds[@]}"
}                                                               # }}}1

# Usage: start_tasks
# Start commands w/ concurrency; uses config; appends to $conc.
function start_tasks ()
{                                                               # {{{1
  local c t l d w; local -i k=0 i j
  for (( i = 0; i < n_tasks; ++i )); do
    eval "c=\${tm_concurrency__${tasks[i]}:-1}"; conc+=( "$c" )
    for (( j = 1; j <= c; ++j )); do
      t="${tasks[i]}.$j"
      eval "l=\${tm_logdir__${tasks[i]}:-\$tm_logdir}"
      eval "d=\${tm_cwd__${tasks[i]}:-\$tm_cwd}"
      eval "w=\${tm_worker__${tasks[i]}:-\$tm_worker}"
      spawn_worker "$i" "$j" "$k" "$t" "$l" "$d" "$w" \
        "${cmds[i]}" "${sigs[i]}"
      (( ++k ))
    done
  done
}                                                               # }}}1

# --

ohai w 'starting...'
ohai w "TASKFILE $tm_tf"

[ -e "$tm_rc" ] && { ohai w "TASKMASTERRC $tm_rc"; source "$tm_rc"; }
[ "$#" -gt 0 ] && concurrency "$@"

tasks=() cmds=() sigs=() pids=() conc=()

parse_Taskfile; start_tasks

trap handle_child_restart SIGUSR1
trap handle_INT           INT
trap handle_TERM          TERM
trap handle_EXIT          EXIT

while :; do; wait && break; done

ohai w 'done'

# vim: set tw=70 sw=2 sts=2 et fdm=marker :
