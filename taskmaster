#!/bin/bash

# --                                                            ; {{{1
#
# File        : taskmaster
# Maintainer  : Felix C. Stegerman <flx@obfusk.net>
# Date        : 2013-07-18
#
# Copyright   : Copyright (C) 2013  Felix C. Stegerman
# Licence     : GPLv2
#
# --                                                            ; }}}1

set -e

# use fd 3 for logging output b/c stderr > stdout otherwise
# WTF: no output if redirected to file w/o >&3
exec 3>/dev/stdout >&3

if [ "$1" == --help ]; then
  echo 'Usage: taskmaster [ <task>=<n> ... ]' >&2; exit 0
fi

# --

if [ -t 1 ]; then use_colour=yes; else use_colour=no; fi

 c_black='0;30'     c_blue='0;34'   c_green='0;32'    c_cyan='0;36'
   c_red='0;31'   c_purple='0;35'   c_brown='0;33'  c_l_gray='0;37'
c_d_gray='1;30'   c_l_blue='1;34' c_l_green='1;32'  c_l_cyan='1;36'
 c_l_red='1;31' c_l_purple='1;35'  c_yellow='1;33'   c_white='1;37'

colours=(
    $c_cyan   $c_brown   $c_green   $c_purple   $c_red   $c_blue
  $c_l_cyan $c_yellow  $c_l_green $c_l_purple $c_l_red $c_l_blue
) ; n_colours="${#colours[@]}" esc=$'\e'

# Usage: colour <msg> { <i> | w }
function colour ()
{                                                               # {{{1
  local msg="$1" i="$2" j c
  if [ "$use_colour" == yes ]; then
    if [ "$i" == w ]; then
      c="$c_white"
    else
      j="$(( i % n_colours ))"; c="${colours[j]}"
    fi
    printf '%s\n' "${esc}[${c}m${msg}${esc}[0m"
  else
    printf '%s\n' "$msg"
  fi
}                                                               # }}}1

# --

tm_rc="${TASKMASTERRC:-.taskmaster}"
tm_tf="${TASKFILE:-Taskfile}"
tm_sh="${TASKMASTER_SHELL:-bash}"

tm_cwd= tm_logdir= tm_supervisor= tm_env=

word='[A-Za-z0-9]+' num='[0-9]+'

# --

# Usage: dt
function dt () { date +'%F %T'; }

# Usage: die
function die () { echo "$@" >&2; exit 1; }

# Usage: ohai { <i> | w } <message(s)>
function ohai ()
{                                                               # {{{1
  local i="$1" o=; shift
  o+="$( colour "taskmaster $(dt)" w )"
  for m in "$@"; do o+=" -- $( colour "$m" "$i" )"; done
  echo "[ $o ]"
}                                                               # }}}1

# Usage: ensure_word <value>
function ensure_word ()
{ [[ "$1" =~ ^$word$ ]] || die "not a word: $1"; }

# --

# Usage: cwd [<task(s)>] <dir>
# Sets $tm_cwd or $tm_cwd__$task.
function cwd ()
{                                                               # {{{1
  ohai w "cwd $*"
  if [ "$#" -eq 1 ]; then
    tm_cwd="$1"
    [ "$VERBOSE" == yes ] && ohai w "cwd=$tm_cwd"
  else
    local x d="${@:$#:1}"
    for x in "${@:1:$(($#-1))}"; do
      ensure_word "$x"; eval "tm_cwd__$x=\$d"
      [ "$VERBOSE" == yes ] && ohai w "cwd[$x]=$d"
    done
  fi
}                                                               # }}}1

# Usage: logdir [<task(s)>] <dir>
# Sets $tm_logdir or $tm_logdir__$task.
function logdir ()
{                                                               # {{{1
  ohai w "logdir $*"
  if [ "$#" -eq 1 ]; then
    tm_logdir="$1"
    [ "$VERBOSE" == yes ] && ohai w "logdir=$tm_logdir"
  else
    local x d="${@:$#:1}"
    for x in "${@:1:$(($#-1))}"; do
      ensure_word "$x"; eval "tm_logdir__$x=\$d"
      [ "$VERBOSE" == yes ] && ohai w "logdir[$x]=$d"
    done
  fi
}                                                               # }}}1

# Usage: supervisor [<task(s)>] { respawn | killall | die }
# Sets $tm_supervisor or $tm_supervisor__$task.
function supervisor ()
{                                                               # {{{1
  ohai w "supervisor $*"
  if [ "$#" -eq 1 ]; then
    tm_supervisor="$1"
    [ "$VERBOSE" == yes ] && ohai w "supervisor=$tm_supervisor"
  else
    local x s="${@:$#:1}"
    for x in "${@:1:$(($#-1))}"; do
      ensure_word "$x"; eval "tm_supervisor__$x=\$s"
      [ "$VERBOSE" == yes ] && ohai w "supervisor[$x]=$s"
    done
  fi
}                                                               # }}}1

# Usage: environment [<task(s)>] VAR1=VAL1 ...
# Sets $tm_env or $tm_env__$task.
function environment ()
{                                                               # {{{1
  ohai w "environment $*"
  local ts=() env i x
  for (( i = 0; i < $#; ++i )); do
    local x="${@:$i:1}"
    if [[ "$x" == ^$word$ ]]; then
      ts+=( "$x" )
    else
      break
    fi
  done
  env=( "${@:$i:$(($#-i))}" )

  if [ "${#ts[@]}" -eq 0 ]; then
    tm_env=( "${env[@]}" )
    [ "$VERBOSE" == yes ] && ohai w "env=${tm_env[*]}"
  else
    for x in "${ts[@]}"; do
      eval "tm_env__$x=( \"\${env[@]}\" )"
      [ "$VERBOSE" == yes ] && ohai w "env[$x]=${env[*]}"
    done
  fi
}                                                               # }}}1

# Usage: concurrency <task1>=<n1> <task2>=<n2> ...
# Sets $tm_concurrency__$task; should be called in $TASKMASTERRC.
function concurrency ()
{                                                               # {{{1
  ohai w "concurrency $*"
  local x t n
  for x in "$@"; do
    [[ "$x" =~ ^($word)=($num)$ ]] || die "not a <word>=<num>: $x"
    t="${BASH_REMATCH[1]}" n="${BASH_REMATCH[2]}"
    eval "tm_concurrency__$t=$n"
    [ "$VERBOSE" == yes ] && ohai w "concurrency[$t]=$n"
  done
}                                                               # }}}1

# --

ohai w 'starting...'

[ -e "$tm_rc" ] && { ohai w "TASKMASTERRC $tm_rc"; source "$tm_rc"; }
[ "$#" -gt 0 ] && concurrency "$@"

tasks=() cmds=() sigs=() pids=() conc=()

# --

# Usage: log <task> { OUT | ERR } { <i> | w }
# Reads from STDIN, then writes to STDOUT w/ extra info.
function log ()
{                                                               # {{{1
  local task="$1" what="$2" i="$3" REPLY
  while read -r; do
    printf '%s %s\n' "$( colour "$(dt) $what $task |" "$i" )" "$REPLY"
  done
}                                                               # }}}1

# Usage: alive <pid>
function alive () { test -n "$( ps -p "$1" -o pid= )"; }

# Usage: kill_ -<sig> <pid>
function kill_ ()
{ [ "$VERBOSE" == yes ] && ohai w "kill $*"; kill "$@"; }

# Usage: kill_w_children -<sig> <pid>
# TODO
# Kills pid, sleeps 1 sec, kills remaining direct children
function kill_w_children ()                                     # {{{1
{
  local sig="$1" pid="$2" p pp ps=()
  while read -r p pp; do [ "$pp" == "$pid" ] && ps+=( "$p" ); done < \
    <( ps -e -o pid= -o ppid= )
  alive "$pid" && kill_ "$sig" "$pid" ; sleep 1
  for p in "${ps[@]}"; do alive "$p" && kill_ "$sig" "$p"; done
  true
}                                                               # }}}1

# --

# Usage: spawn <cmd>
function spawn () { "$tm_sh" -c "$1"; }

# Usage: supervise <i> <k> <t> <cmd> { respawn | killall | die }
# TODO: maxR + maxT
function supervise ()
{
  local i="$1" k="$2" t="$3" cmd="$4" sup="$5"
  spawn "$cmd" & local pid=$!
  echo spawned "$pid" >&4
  wait "$pid"
  echo "$sup" "$i" "$k" "$t" "$pid" "$?" >&4
  [ "$sup" == respawn ] && spawn "$@"
}

# Usage: tm_supervisor
# TODO
function tm_supervisor ()
{                                                               # {{{1
  local cmd pids=() x i k t pid; local -i n=-1 n_dead=0
  while read -r -a cmd; do
    case "${cmd[0]}" in
      shutdown)
        for x in "${pids[@]}"; do
          ohai w "killing $x"
          kill -SIGTERM "$x"
        done
      ;;
      start)
        ohai w "starting supervisor"
        n="${cmd[1]}"; [ "$n_dead" -eq "$n" ] && return 0
      ;;
      spawned)
        sup="${cmd[0]}" i="${cmd[1]}" k="${cmd[2]}" t="${cmd[3]}"
        pid="${cmd[4]}" ret="${cmd[5]}"
        ohai "$i" "start $t" "pid=$pid"
        pids["$k"]="$pid"
      ;;
      # ...
    esac
  done
  return 1
}                                                               # }}}1

# --

function cleanup () { echo shutdown >&4; wait "$sup"; }

# Kills processes; notifies; used by trap.
# NB: we kill all direct child processes of >> $tm_sh -c <<.
# TODO
function cleanup_old ()
{                                                               # {{{1
  local k=0 i c j t
  for (( i = 0; i < n_tasks; ++i )); do
    c="${conc[i]}"
    for (( j = 1; j <= c; ++j )); do
      t="${tasks[i]}.$j"
      ohai "$i" "kill $t" "signal=${sigs[i]} pid=${pids[k]}"
      kill_w_children -"${sigs[i]}" "${pids[k]}" &
      (( ++k ))
    done
  done
  wait
}                                                               # }}}1

# --

ohai w "TASKFILE $tm_tf"

# Parse $tm_tf; read w/o -r allows for continuation lines; appends to
# $tasks, $cmds, $sigs.
while read task cmd; do                                         # {{{1
  [[ "$task" =~ ^($word):$ ]] || die "not a <task>: $task"
  t="${BASH_REMATCH[1]}"
  if [[ "$cmd" =~ ^(SIG[A-Z0-9]+\ *)(.*)$ ]]; then
    s="${BASH_REMATCH[1]}" c="${BASH_REMATCH[2]}"
  else
    s=SIGTERM c="$cmd"
  fi
  tasks+=( "$t" ); cmds+=( "$c" ); sigs+=( "$s" )
done < "$tm_tf"                                                 # }}}1

n_tasks="${#cmds[@]}"

# TODO
# coproc SUPERVISOR ( tm_supervisor ); sup=$!

# Start commands w/ concurrency; uses $tm_logdir_$task/$tm_logdir/log;
# appends to $conc, $pids; notifies.
k=0
for (( i = 0; i < n_tasks; ++i )); do                           # {{{1
  eval "c=\${tm_concurrency__${tasks[i]}:-1}"; conc+=( "$c" )
  for (( j = 1; j <= c; ++j )); do
    t="${tasks[i]}.$j"
    eval "l=\${tm_logdir__${tasks[i]}:-\$tm_logdir}"
    eval "d=\${tm_cwd__${tasks[i]}:-\$tm_cwd}"
    eval "s=\${tm_supervisor__${tasks[i]}:-\$tm_supervisor}"
    [ -n "$d" ] && { pushd "$d" >/dev/null || exit 1; }
      run=( supervise "$i" "$k" "$t" "${cmds[i]}" "${s:-die}" )
      if [ -n "$l" ]; then
        "${run[@]}" >> "$l/$t-stdout.log" \
                   2>> "$l/$t-stderr.log" &
      else
        "${run[@]}" > >( log "$t" OUT "$i" >&3 ) \
                   2> >( log "$t" ERR "$i" >&3 ) &
      fi
      pids+=( $! )
    [ -n "$d" ] && { popd >/dev/null || exit 1; }
    (( ++k ))
  done
done                                                            # }}}1

# --

trap cleanup SIGINT SIGTERM

echo start "${#pids[@]}" >&4

if [ "${#pids[@]}" -eq 0 ]; then
  ohai w 'no processes to start'
else
  ohai w 'done'
fi

# vim: set tw=70 sw=2 sts=2 et fdm=marker :
