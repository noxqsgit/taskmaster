#!/bin/bash

# --                                                            ; {{{1
#
# File        : taskmaster
# Maintainer  : Felix C. Stegerman <flx@obfusk.net>
# Date        : 2013-07-18
#
# Copyright   : Copyright (C) 2013  Felix C. Stegerman
# Licence     : GPLv2
#
# --                                                            ; }}}1

set -e

if [ "$1" == --help ]; then
  echo 'Usage: taskmaster [ <task>=<n> ... ]' >&2; exit 0
fi

tm_rc="${TASKMASTERRC:-.taskmaster}"
tm_tf="${TASKFILE:-Taskfile}"
tm_sh="${TASKMASTER_SHELL:-bash}"

# Usage: dt
function dt () { date +'%F %T'; }

# Usage: ohai <message>
function ohai () { echo "[ taskmaster -- $(dt) -- $1 ]"; }

ohai 'starting...'

# --

# Usage: cwd [<task>] <dir>
# Sets $tm_cwd or $tm_cwd__$task.
function cwd ()
{                                                               # {{{1
  ohai "cwd $*"
  if [ "$#" -eq 2 ]; then
    local t="$1" d="$2"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    eval "tm_cwd__$t=\$d"
  else
    tm_cwd="$1"
  fi
}                                                               # }}}1

# Usage: logdir [<task>] <dir>
# Sets $logdir or $logdir__$task.
function logdir ()
{                                                               # {{{1
  ohai "logdir $*"
  if [ "$#" -eq 2 ]; then
    local t="$1" d="$2"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    eval "logdir__$t=\$d"
  else
    logdir="$1"
  fi
}                                                               # }}}1

# Usage: concurrency <task1>=<n1> <task2>=<n2> ...
# Sets $concurrency__$task; should be called in $TASKMASTERRC.
function concurrency ()
{                                                               # {{{1
  ohai "concurrency $*"
  local x t n
  for x in "$@"; do
    t="${x%=*}" n="${x##*=}"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    [[ "$n" =~ ^[0-9]+$       ]] || exit 1
    eval "concurrency__$t=$n"
  done
}                                                               # }}}1

[ -e "$tm_rc" ] && { ohai "TASKMASTERRC $tm_rc"; source "$tm_rc"; }
[ "$#" -gt 0 ] && concurrency "$@"

# --

tasks=() cmds=() sigs=() pids=() conc=()

# Usage: log <task> { STDOUT | STDERR }
# Reads from STDIN, then writes to STDOUT w/ extra info.
function log ()
{                                                               # {{{1
  local task="$1" what="$2" REPLY
  while read -r; do
    printf '[%s %s %s] %s\n' "$task" "$what" "$(dt)" "$REPLY"
  done
}                                                               # }}}1

# Usage: alive <pid>
function alive { test -n "$( ps -p "$1" -o pid= )"; }

# Usage: kill_ -<sig> <pid>
function kill_ { [ "$VERBOSE" == yes ] && ohai "kill $*"; kill "$@"; }

# Usage: kill_w_children -<sig> <pid>
# Kills pid, sleeps 1 sec, kills remaining direct children
function kill_w_children                                        # {{{1
{
  local sig="$1" pid="$2" p pp ps=()
  while read p pp; do [ "$pp" == "$pid" ] && ps+=( "$p" ); done < \
    <( ps -e -o pid= -o ppid= )
  alive "$pid" && kill_ "$sig" "$pid" ; sleep 1
  for p in "${ps[@]}"; do alive "$p" && kill_ "$sig" "$p"; done
  true
}                                                               # }}}1

# --

ohai "TASKFILE $tm_tf"

# Parse $tm_tf; read w/o -r allows for continuation lines; appends to
# $tasks, $cmds, $sigs.
while read task cmd; do                                         # {{{1
  t="${task%:}"
  if [[ "$cmd" =~ ^SIG[A-Z0-9]+' ' ]]; then
    s="${cmd%% *}" c="${cmd#* }"
  else
    s=SIGTERM c="$cmd"
  fi
  tasks+=( "$t" ); cmds+=( "$c" ); sigs+=( "$s" )
done < "$tm_tf"                                                 # }}}1

n_tasks="${#cmds[@]}"

# use fd 3 for logging output b/c stderr > stdout otherwise
exec 3>/dev/stdout

# Start commands w/ concurrency; uses $logdir_$task/$logdir/log;
# appends to $conc, $pids; notifies.
for (( i = 0; i < n_tasks; ++i )); do                           # {{{1
  eval "c_=\$concurrency__${tasks[i]}"; c="${c_:-1}"; conc+=( "$c" )
  for (( j = 1; j <= c; ++j )); do
    t="${tasks[i]}.$j"
    eval "l_=\$logdir__${tasks[i]}"; l="${l_:-$logdir}"
    eval "d_=\$tm_cwd__${tasks[i]}"; d="${d_:-$tm_cwd}"

    [ -n "$d" ] && { pushd "$d" >/dev/null || exit 1; }

      if [ -n "$l" ]; then
        p="$( readlink -f "$l" )/$t"
        "$tm_sh" -c "${cmds[i]}" >> "$p-stdout.log" \
                                2>> "$p-stderr.log" &
      else
        "$tm_sh" -c "${cmds[i]}" > >( log "$t" STDOUT >&3 ) \
                                2> >( log "$t" STDERR >&3 ) &
      fi
      pid=$!; pids+=( "$pid" )
      ohai "start $t -- pid=$pid"

    [ -n "$d" ] && { popd >/dev/null || exit 1; }
  done
done                                                            # }}}1

# Kills processes; notifies; used by trap.
# NB: we kill all direct child processes of >> $tm_sh -c <<.
function cleanup ()
{                                                               # {{{1
  local k=0 i j t d
  for (( i = 0; i < n_tasks; ++i )); do
    c="${conc[i]}"
    for (( j = 1; j <= c; ++j )); do
      t="${tasks[i]}.$j"
      ohai "kill $t -- signal=${sigs[i]} pid=${pids[k]}"
      kill_w_children -"${sigs[i]}" "${pids[k]}"
      (( ++k ))
    done
  done
}                                                               # }}}1

# --

trap cleanup SIGINT SIGTERM
wait

ohai 'done'

# vim: set tw=70 sw=2 sts=2 et fdm=marker :
