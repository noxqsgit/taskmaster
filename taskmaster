#!/bin/bash

set -e

if [ "$1" == --help ]; then
  echo 'Usage: taskmaster [ <task>=<n> ... ]' >&2; exit 0
fi

tm_rc="${TASKMASTERRC:-.taskmaster}"
tm_tf="${TASKFILE:-Taskfile}"

# Usage: dt
function dt () { date +'%F %T'; }

# Usage: ohai <message>
function ohai () { echo "[ taskmaster -- $(dt) -- $1 ]"; }

ohai 'starting...'

# --

# Usage: cwd [<task>] <dir>
# Sets $tm_cwd or $tm_cwd__$task.
function cwd ()
{                                                               # {{{1
  ohai "cwd $@"
  if [ "$#" -eq 2 ]; then
    local t="$1" d="$2"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    eval "tm_cwd__$t=\$d"
  else
    tm_cwd="$1"
  fi
}                                                               # }}}1

# Usage: logdir [<task>] <dir>
# Sets $logdir or $logdir__$task.
function logdir ()
{                                                               # {{{1
  ohai "logdir $@"
  if [ "$#" -eq 2 ]; then
    local t="$1" d="$2"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    eval "logdir__$t=\$d"
  else
    logdir="$1"
  fi
}                                                               # }}}1

# Usage: concurrency <task1>=<n1> <task2>=<n2> ...
# Sets $concurrency__$task; should be called in $TASKMASTERRC.
function concurrency ()
{                                                               # {{{1
  ohai "concurrency $@"
  local x t n
  for x in "$@"; do
    t="${x%=*}" n="${x##*=}"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    [[ "$n" =~ ^[0-9]+$       ]] || exit 1
    eval "concurrency__$t=$n"
  done
}                                                               # }}}1

[ -e "$tm_rc" ] && { ohai "TASKMASTERRC $tm_rc"; source "$tm_rc"; }
[ "$#" -gt 0 ] && concurrency "$@"

# --

tasks=() cmds=() sigs=() pids=() conc=()

# Usage: log <task> { STDOUT | STDERR }
# Reads from STDIN, then writes to STDOUT w/ extra info.
function log ()
{                                                               # {{{1
  local task="$1" what="$2" REPLY
  while read -r; do
    printf '[%s %s %s] %s\n' "$task" "$what" "$(dt)" "$REPLY"
  done
}                                                               # }}}1

# --

ohai "TASKFILE $tm_tf"

# Parse $tm_tf; read w/o -r allows for continuation lines; appends to
# $tasks, $cmds, $sigs.
while read task cmd; do                                         # {{{1
  t="${task%:}"
  if [[ "$cmd" =~ ^SIG[A-Z0-9]+' ' ]]; then
    s="${cmd%% *}" c="${cmd#* }"
  else
    s=SIGTERM c="$cmd"
  fi
  tasks+=( "$t" ); cmds+=( "$c" ); sigs+=( "$s" )
done < "$tm_tf"                                                 # }}}1

n_tasks="${#cmds[@]}"

# Start commands w/ concurrency; uses $logdir_$task/$logdir/log;
# appends to $conc, $pids; notifies.
for (( i = 0; i < n_tasks; ++i )); do                           # {{{1
  eval "c_=\$concurrency__${tasks[i]}"; c="${c_:-1}"; conc+=( "$c" )
  for (( j = 1; j <= c; ++j )); do
    t="${tasks[i]}.$j"
    eval "l_=\$logdir__${tasks[i]}"; l="${l_:-$logdir}"
    eval "d_=\$tm_cwd__${tasks[i]}"; d="${d_:-$tm_cwd}"

    [ -n "$d" ] && { pushd "$d" >/dev/null || exit 1 }

      if [ -n "$l" ]; then
        p="$( readlink -f "$l" )/$t"
        sh -c "${cmds[i]}" >> "$p-stdout.log" \
                          2>> "$p-stderr.log" &
      else
        sh -c "${cmds[i]}" > >( log "$t" STDOUT ) \
                          2> >( log "$t" STDERR ) &
      fi
      pid=$!; pids+=( "$pid" )
      ohai "start $t -- pid=$pid"

    [ -n "$d" ] && { popd >/dev/null || exit 1 }
  done
done                                                            # }}}1

# Kills processes; notifies; used by trap.
# NB: we use >> pkill -P << to kill all subprocesses of >> sh -c <<,
# but NOT the entire process group.
function cleanup ()
{                                                               # {{{1
  local k=0 i j t d
  for (( i = 0; i < n_tasks; ++i )); do
    c="${conc[i]}"
    for (( j = 1; j <= c; ++j )); do
      t="${tasks[i]}.$j"
      ohai "kill $t -- signal=${sigs[i]} pid=${pids[k]}"
      pkill -"${sigs[i]}" -P  "${pids[k]}" || true
      kill  -"${sigs[i]}"     "${pids[k]}" || true
      (( ++k ))
    done
  done
}                                                               # }}}1

# --

trap cleanup SIGINT SIGTERM
wait

ohai 'done'

# vim: set tw=70 sw=2 sts=2 et fdm=marker :
