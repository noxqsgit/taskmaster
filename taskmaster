#!/bin/bash

# --                                                            ; {{{1
#
# File        : taskmaster
# Maintainer  : Felix C. Stegerman <flx@obfusk.net>
# Date        : 2013-07-18
#
# Copyright   : Copyright (C) 2013  Felix C. Stegerman
# Licence     : GPLv2
#
# --                                                            ; }}}1

set -e

# use fd 3 for logging output b/c stderr > stdout otherwise
exec 3>/dev/stdout >&3 # WTF

if [ "$1" == --help ]; then
  echo 'Usage: taskmaster [ <task>=<n> ... ]' >&2; exit 0
fi

# --

if [ -t 1 ]; then use_colour=yes; else use_colour=no; fi

 c_black='0;30'     c_blue='0;34'   c_green='0;32'    c_cyan='0;36'
   c_red='0;31'   c_purple='0;35'   c_brown='0;33'  c_l_gray='0;37'
c_d_gray='1;30'   c_l_blue='1;34' c_l_green='1;32'  c_l_cyan='1;36'
 c_l_red='1;31' c_l_purple='1;35'  c_yellow='1;33'   c_white='1;37'

colours=(
    $c_cyan   $c_brown   $c_green   $c_purple   $c_red   $c_blue
  $c_l_cyan $c_yellow  $c_l_green $c_l_purple $c_l_red $c_l_blue
) ; n_colours="${#colours[@]}" esc=$'\e'

# Usage: colour <msg> { <i> | w }
function colour ()
{                                                               # {{{1
  local msg="$1" i="$2" j c
  if [ "$use_colour" == yes ]; then
    if [ "$i" == w ]; then
      c="$c_white"
    else
      j="$(( i % n_colours ))"; c="${colours[j]}"
    fi
    printf '%s\n' "${esc}[${c}m${msg}${esc}[0m"
  else
    printf '%s\n' "$msg"
  fi
}                                                               # }}}1

# --

tm_rc="${TASKMASTERRC:-.taskmaster}"
tm_tf="${TASKFILE:-Taskfile}"
tm_sh="${TASKMASTER_SHELL:-bash}"

# --

# Usage: dt
function dt () { date +'%F %T'; }

# Usage: ohai { <i> | w } <message(s)>
function ohai ()
{                                                               # {{{1
  local i="$1"; shift
  echo -n "[ $( colour "taskmaster $(dt)" w )"
  for m in "$@"; do
    printf '%s' " -- $( colour "$m" "$i" )"
  done
  echo " ]"
}                                                               # }}}1

ohai w 'starting...'

# --

# Usage: cwd [<task>] <dir>
# Sets $tm_cwd or $tm_cwd__$task.
function cwd ()
{                                                               # {{{1
  ohai w "cwd $*"
  if [ "$#" -eq 2 ]; then
    local t="$1" d="$2"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    eval "tm_cwd__$t=\$d"
  else
    tm_cwd="$1"
  fi
}                                                               # }}}1

# Usage: logdir [<task>] <dir>
# Sets $logdir or $logdir__$task.
function logdir ()
{                                                               # {{{1
  ohai w "logdir $*"
  if [ "$#" -eq 2 ]; then
    local t="$1" d="$2"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    eval "logdir__$t=\$d"
  else
    logdir="$1"
  fi
}                                                               # }}}1

# Usage: concurrency <task1>=<n1> <task2>=<n2> ...
# Sets $concurrency__$task; should be called in $TASKMASTERRC.
function concurrency ()
{                                                               # {{{1
  ohai w "concurrency $*"
  local x t n
  for x in "$@"; do
    t="${x%=*}" n="${x##*=}"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    [[ "$n" =~ ^[0-9]+$       ]] || exit 1
    eval "concurrency__$t=$n"
  done
}                                                               # }}}1

[ -e "$tm_rc" ] && { ohai w "TASKMASTERRC $tm_rc"; source "$tm_rc"; }
[ "$#" -gt 0 ] && concurrency "$@"

# --

tasks=() cmds=() sigs=() pids=() conc=()

# Usage: log <task> { OUT | ERR } { <i> | w }
# Reads from STDIN, then writes to STDOUT w/ extra info.
function log ()
{                                                               # {{{1
  local task="$1" what="$2" i="$3" REPLY
  while read -r; do
    printf '%s %s\n' "$( colour "$(dt) $what $task |" "$i" )" "$REPLY"
  done
}                                                               # }}}1

# Usage: alive <pid>
function alive { test -n "$( ps -p "$1" -o pid= )"; }

# Usage: kill_ -<sig> <pid>
function kill_
{ [ "$VERBOSE" == yes ] && ohai w "kill $*"; kill "$@"; }

# Usage: kill_w_children -<sig> <pid>
# Kills pid, sleeps 1 sec, kills remaining direct children
function kill_w_children                                        # {{{1
{
  local sig="$1" pid="$2" p pp ps=()
  while read -r p pp; do [ "$pp" == "$pid" ] && ps+=( "$p" ); done < \
    <( ps -e -o pid= -o ppid= )
  alive "$pid" && kill_ "$sig" "$pid" ; sleep 1
  for p in "${ps[@]}"; do alive "$p" && kill_ "$sig" "$p"; done
  true
}                                                               # }}}1

# --

ohai w "TASKFILE $tm_tf"

# Parse $tm_tf; read w/o -r allows for continuation lines; appends to
# $tasks, $cmds, $sigs.
while read task cmd; do                                         # {{{1
  t="${task%:}"
  if [[ "$cmd" =~ ^SIG[A-Z0-9]+' ' ]]; then
    s="${cmd%% *}" c="${cmd#* }"
  else
    s=SIGTERM c="$cmd"
  fi
  tasks+=( "$t" ); cmds+=( "$c" ); sigs+=( "$s" )
done < "$tm_tf"                                                 # }}}1

n_tasks="${#cmds[@]}"

# Start commands w/ concurrency; uses $logdir_$task/$logdir/log;
# appends to $conc, $pids; notifies.
for (( i = 0; i < n_tasks; ++i )); do                           # {{{1
  eval "c_=\$concurrency__${tasks[i]}"; c="${c_:-1}"; conc+=( "$c" )
  for (( j = 1; j <= c; ++j )); do
    t="${tasks[i]}.$j"
    eval "l_=\$logdir__${tasks[i]}"; l="${l_:-$logdir}"
    eval "d_=\$tm_cwd__${tasks[i]}"; d="${d_:-$tm_cwd}"

    [ -n "$d" ] && { pushd "$d" >/dev/null || exit 1; }

      if [ -n "$l" ]; then
        p="$( readlink -f "$l" )/$t"
        "$tm_sh" -c "${cmds[i]}" >> "$p-stdout.log" \
                                2>> "$p-stderr.log" &
      else
        "$tm_sh" -c "${cmds[i]}" > >( log "$t" OUT "$i" >&3 ) \
                                2> >( log "$t" ERR "$i" >&3 ) &
      fi
      pid=$!; pids+=( "$pid" )
      ohai "$i" "start $t" "pid=$pid"

    [ -n "$d" ] && { popd >/dev/null || exit 1; }
  done
done                                                            # }}}1

# Kills processes; notifies; used by trap.
# NB: we kill all direct child processes of >> $tm_sh -c <<.
function cleanup ()
{                                                               # {{{1
  local k=0 i j t d
  for (( i = 0; i < n_tasks; ++i )); do
    c="${conc[i]}"
    for (( j = 1; j <= c; ++j )); do
      t="${tasks[i]}.$j"
      ohai "$i" "kill $t" "signal=${sigs[i]} pid=${pids[k]}"
      kill_w_children -"${sigs[i]}" "${pids[k]}"
      (( ++k ))
    done
  done
}                                                               # }}}1

# --

trap cleanup SIGINT SIGTERM
wait

ohai w 'done'

# vim: set tw=70 sw=2 sts=2 et fdm=marker :
