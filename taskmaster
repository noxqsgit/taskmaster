#!/bin/bash

set -e

if [ "$1" == --help ]; then
  echo 'Usage: taskmaster [ <task>=<n> ... ]' >&2; exit 0
fi

# --

# Usage: logdir [<task>] <dir>
# Sets $logdir or $logdir__$task.
function logdir ()
{                                                               # {{{1
  if [ "$#" -eq 2]; then
    local t="$1" d="$2"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    eval "logdir__$t=\$d"
  else
    logdir="$1"
  fi
}                                                               # }}}1

# Usage: concurrency <task1>=<n1> <task2>=<n2> ...
# Sets $concurrency__$task; should be called in $TASKMASTERRC.
function concurrency ()
{                                                               # {{{1
  local x t n
  for x in "$@"; do
    t="${x%=*}" n="${x##*=}"
    [[ "$t" =~ ^[A-Za-z0-9]+$ ]] || exit 1
    [[ "$n" =~ ^[0-9]+$       ]] || exit 1
    eval "concurrency__$t=$n"
  done
}                                                               # }}}1

cfgfile="${TASKMASTERRC:-.taskmaster}"
[ -e "$cfgfile" ] && source "$cfgfile"
[ "$#" -gt 0 ] && concurrency "$@"

# --

tasks=() cmds=() sigs=() pids=() conc=()

function dt () { date +'%F %T'; }

# Usage: log <task> { STDOUT | STDERR }
# Reads from STDIN, then writes to STDOUT w/ extra info.
function log ()
{                                                               # {{{1
  local task="$1" what="$2" REPLY
  while read -r; do
    printf '[%s %s %s] %s\n' "$task" "$what" "$(dt)" "$REPLY"
  done
}                                                               # }}}1

# --

# Parse $TASKFILE; read w/o -r allows for continuation lines; appends
# to $tasks, $cmds, $sigs.
while read task cmd; do                                         # {{{1
  t="${task%:}"
  if [[ "$cmd" =~ ^SIG[A-Z0-9]+' ' ]]; then
    s="${cmd%% *}" c="${cmd#* }"
  else
    s=SIGTERM c="$cmd"
  fi
  tasks+=( "$t" ); cmds+=( "$c" ); sigs+=( "$s" )
done < "${TASKFILE:-Taskfile}"                                  # }}}1

n_tasks="${#cmds[@]}"

# Start commands w/ concurrency; uses $logdir_$task/$logdir/log;
# appends to $conc, $pids; notifies.
for (( i = 0; i < n_tasks; ++i )); do                           # {{{1
  eval "c_=\$concurrency__${tasks[i]}"; c="${c_:-1}"; conc+=( "$c" )
  for (( j = 1; j <= c; ++j )); do
    t="${tasks[i]}.$j"; eval "l_=\$logdir__${tasks[i]}"
    l="${l_:-$logdir}"
    if [ -n "$l" ]; then
      p="$l/$t"
      sh -c "${cmds[i]}" >> "$p-stdout.log" \
                        2>> "$p-stderr.log" &
    else
      sh -c "${cmds[i]}" > >( log "$t" STDOUT ) \
                        2> >( log "$t" STDERR ) &
    fi
    pid=$!; pids+=( "$pid" )
    echo "[taskmaster -- $(dt) -- start $t -- pid=$pid]"
  done
done                                                            # }}}1

# Kills processes; notifies; used by trap.
function cleanup ()
{                                                               # {{{1
  local k=0 i j t d
  for (( i = 0; i < n_tasks; ++i )); do
    c="${conc[i]}"
    for (( j = 1; j <= c; ++j )); do
      t="${tasks[i]}.$j"
      echo "[taskmaster -- $(dt) -- kill $t -- signal=${sigs[i]}]"
      kill -s "${sigs[i]}" "${pids[k]}"; (( ++k ))
    done
  done
}                                                               # }}}1

trap stop SIGINT SIGTERM EXIT
wait

# vim: set tw=70 sw=2 sts=2 et fdm=marker :
